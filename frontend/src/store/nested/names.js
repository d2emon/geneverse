/*
RandomGen - main generation code
All this code by Orteil, 2014. Please do not reproduce without permission. Do not claim ownership.
A few things :
	-This is really messy. It's all tangled-up and hardly commented at all. This is mostly because a lot of it was written through trial and error. Sorry.
	-I could probably use regexes, but I'm really bad at those - so we're parsing data the dumb way most of the time.
	-Feel free to browse through and see how it's made, if you can get past the bad code and quirky work-arounds.

TODO :
	-log of last generated text and generators used
	-forum board
	-more stock generators (synonym dictionaries : http://writeworld.tumblr.com/post/64299338442/synonyms-for-words-commonly-used-in-students-writings )
	-switches (close off entire lists depending on a dynamic setting)
	-quick edit
	-negative rand numbers
	-document "hidden", "allow duplicates", "lower", "compress", "first" "middle" "last part"

Quick tutorial :
	-To create a random generator, you simply have to define lists of things that reference each other. For example :
		$animal
		cat
		dog
		fish

		$phrase
		My pet is a [animal].
		I am feeding my [animal].
	-This will generate sentences such as "My pet is a cat", or "I am feeding my fish".
	-The last list declared will be used as the base generator.
	-You can change how many items are generated by adding "&amount=10" to the url; you can also change the base generator by adding "&seed=element".

Bugs :
	-"[I'm cool|you're lame]" can return "You're lame" - fix case
	-check this out :
	$art
	the
	[an]
	$out
	[*DEBUG ON*][An] [apple|cake].
	->[an] doesn't get capitalized (but does with [An,ABC])
	-[|[stuff]] returns stuff always (uniques at work ?)
	-amount not working in includes (add a reset)
	-"the subject was found with 40 purple pocket function watch() { [native code] } embedded inside his torso" WHAT
	-probably tons more oh god
*/

function l(what){return document.getElementById(what);}
function choose(arr) {return arr[Math.floor(Math.random()*arr.length)];}
function chooseWithLimits(arr,limits)
{
	var arr2=[];
	var text=0;
	if (arr.length>0 && arr[0].text) text=1;
//	var str=[];for (var i in arr){str.push(arr[i].text||arr[i]);}
//	console.log('Trying to find a unique element in '+str.join('|')+'. The limits are '+limits.join('|')+'.');
	for (var i in arr)
	{
		if (limits.indexOf((text?arr[i].text:arr[i]))==-1) arr2.push(arr[i]);
	}
	if (arr2.length==0) return arr[Math.floor(Math.random()*arr.length)];
	else return arr2[Math.floor(Math.random()*arr2.length)];
}

function escapeRegExp(str){return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");}
function replaceAll(find,replace,str){return str.replace(new RegExp(escapeRegExp(find),'g'),replace);}

allowedTags=['b','i','u','q','p','small','big','center','h1','h2','h3','br'];
function sanitize(str)//when we only want to allow certain html tags
{
	for (var i in allowedTags)
	{
		str=replaceAll('<'+allowedTags[i]+'>','{{{'+allowedTags[i]+'}}}',str);
		str=replaceAll('</'+allowedTags[i]+'>','{{{/'+allowedTags[i]+'}}}',str);
	}
	str=escapeHtml(str);
	for (var i in allowedTags)
	{
		str=replaceAll('{{{'+allowedTags[i]+'}}}','<'+allowedTags[i]+'>',str);
		str=replaceAll('{{{/'+allowedTags[i]+'}}}','</'+allowedTags[i]+'>',str);
	}
	return str;
}
function tidy(htmldata)//from http://stackoverflow.com/questions/8933428/how-to-close-html-tags-in-javascript , should close all hanging tags
{
	var d=document.createElement('div');
	d.innerHTML=htmldata;
	return d.innerHTML;
}

function beginsWith(me,what){return (me.indexOf(what)==0);}
function Cap(str){return str.charAt(0).toUpperCase()+str.slice(1);}
function Title(what)
{
	//Changes a string like "the cat is on the table" to "the Cat Is on the Table"
	what=what.split(' ');
	var toReturn='';
	for (var i in what)
	{
		if (what[i]!='of' && what[i]!='in' && what[i]!='on' && what[i]!='and' && what[i]!='the' && what[i]!='an' && what[i]!='a' && what[i]!='with' && what[i]!='to' && what[i]!='for') what[i]=what[i].substring(0,1).toUpperCase()+what[i].substring(1);
		toReturn+=' '+what[i];
	}
	return toReturn.substring(1);
}

function ajax(url,callback){
	var ajaxRequest;
	try{ajaxRequest = new XMLHttpRequest();} catch (e){try{ajaxRequest=new ActiveXObject('Msxml2.XMLHTTP');} catch (e) {try{ajaxRequest=new ActiveXObject('Microsoft.XMLHTTP');} catch (e){alert("Something broke!");return false;}}}
	if (callback){ajaxRequest.onreadystatechange=function(){if(ajaxRequest.readyState==4){callback(ajaxRequest.responseText);}}}
	ajaxRequest.open('GET',url+'&nocache='+(new Date().getTime()),true);ajaxRequest.send(null);
}

function AddEvent(html_element, event_name, event_function)
{
	if(html_element.attachEvent)//Internet Explorer
		html_element.attachEvent("on" + event_name, function() {event_function.call(html_element);});
	else if(html_element.addEventListener)//Firefox & company
		html_element.addEventListener(event_name, event_function, false);//don't need the 'call' trick because in FF everything already works in the right way
}

function getUrlVars()
{
	var vars={};
	var loc=window.location.href.replace('#','');//hack to get rid of hash
	var parts=loc.replace(/[?&]+([^=&]+)=([^&]*)/gi,
		function(m,key,value)
		{
			vars[key]=value;
		}
	);
	return vars;
}
function escapeHtml(str)
{
	var div=document.createElement('div');
	div.appendChild(document.createTextNode(str));
	return div.innerHTML;
};

function log(str)
{
	if (Game.debugging) console.log(Array(Game.nesting+1).join('	')+'| '+str);
}

function edit()
{
	l('edit').style.display='block';
}

Game={};
Game.ready=0;
Game.Init=function()
{
	Game.ready=1;
	l('loading').innerHTML='Loading generator...';
	l('game').className='generatorLoading';

	Game.FetchGame=function()
	{
		ajax('server.php?q=gettxt|'+Game.src,Game.FetchGameResponse);
	}
	Game.FetchGameResponse=function(response)
	{
		if (Game.src!='')
		{
			Game.ParseData(response);
		}
	}

	Game.Reset=function()
	{
		Game.debugging=0;
		Game.nesting=0;
		Game.identified=[];
		Game.uniques=[];
		Game.commenting=0;
	}

	Game.inList=0;
	Game.ListNames=[];
	Game.Lists={};
	Game.List=function(name,data)
	{
		this.name=name.toLowerCase();
		this.data=data||[];

		this.toStr=function()
		{
			var str=[];
			for (var i in this.data)
			{str.push(this.data[i].text);}
			return str.join(' / ');
		}
		this.Generate=function(as,toObj)
		{
			var as=as||'';
			if (Game.nesting>30) {console.log('Too much nesting is going on. Things are invoking themselves in a loop! Please try again.');throw {name:'FatalError',message:'Too much nesting; possible recursion.'};}
			//var out=choose(this.data);

			var pickedData=[];
			for (var i in this.data)
			{
				if (Math.random()<this.data[i].tags.chance) pickedData.push(this.data[i]);
			}
			var out='';
			var picked={'text':'','tags':[],'type':''};
			if (pickedData.length>0)
			{
				picked=chooseWithLimits(pickedData,Game.uniques);
			}

			var list=[];
			for (var i in pickedData) {list.push(pickedData[i].text);}
			log('Picking between '+list.join(',')+'. Picked "'+picked.text+'"!');

			if (toObj)
			{
				//return Game.ParseToObj(picked.text);
				return picked;
			}
			else
			{
				return Game.ToText(picked,as);
			}
		}

		Game.Lists[this.name]=this;
		Game.ListNames.push(this.name);
	}

	Game.ToText=function(obj,as)
	{
		var as=as||'';
		var out='';
		if (as!='' && obj.tags && obj.tags.custom[as]) out=obj.tags.custom[as];
		//else if (as!='') out='';
		else out=obj.text;
		log('Turning '+obj.text+' to text.');
		out=Game.Parse(out);
		log('Turned '+obj.text+' into '+out+'.');
		//out=Game.Reparse(out);
		return out;
	}

	Game.GetCase=function(str)
	{
		if (str==str.toLowerCase()) return 'abc';
		else if (str==str.toUpperCase()) return 'ABC';
		else if (str.charAt(0)==str.charAt(0).toUpperCase()) return 'Abc';
		else return 'abc';
	}
	Game.SetCase=function(str,format)
	{
		if (format=='abc') return str;//str.toLowerCase();
		else if (format=='ABC') return str.toUpperCase();
		else return str.charAt(0).toUpperCase()+str.slice(1);
	}

	Game.ParseData=function(data)
	{
		var originalData=data;
		//clean up

		//collapse tabs etc into single spaces
		data=replaceAll(String.fromCharCode(10),String.fromCharCode(13),data);
		data=replaceAll(String.fromCharCode(13),'[linebreak]',data);
		data=data.replace(/\s+/g,' ');
		data=replaceAll('[linebreak]',String.fromCharCode(13),data);
		//data=replaceAll(String.fromCharCode(13)+String.fromCharCode(32),String.fromCharCode(13),data);
		//data=replaceAll(String.fromCharCode(13)+String.fromCharCode(45),String.fromCharCode(13),data);

		//for (var i=0;i<40;i++){str+=data.charCodeAt(i)+' : '+data.charAt(i)+'<br>';}

		//split into lines
		data=data.split(String.fromCharCode(13));

		//create lists
		for (var i in data)
		{
			Game.ParseLine(data[i]);
		}

		document.title=sanitize(Game.name)+' by '+sanitize(Game.author)+' | made with RandomGen by Orteil';
		l('gameNameAndAuthor').innerHTML='<span id="gameName">'+sanitize(Game.name)+'</span><span id="gameAuthor"> by '+sanitize(Game.author)+'</span>';
		l('gameDesc').innerHTML=sanitize(Game.desc);
		if (Game.picture!='') {l('pic').style.display='block';l('pic').style.backgroundImage='url('+Game.picture+')';}
		l('generateButton').innerHTML=sanitize(Game.again);
		l('game').className='generatorLoaded';
		l('amountInput').value=Game.amount||'1';
		var src=Game.src;
		if (src.indexOf('www.')==-1 && src.indexOf('http://')==-1 && src.indexOf('https://')==-1)
		{
			if (src.indexOf('.txt')==-1) src='http://pastebin.com/raw.php?i='+src;
			else src='http://orteil.dashnet.org/randomgen/gens/'+src;
		}
		l('gameSource').href=sanitize(src);

		Game.Generate();
	}

	Game.ParseLine=function(data)
	{
		if (beginsWith(data,'//'))//comment
		{
			//~absolutely nothing~
		}
		else if (beginsWith(data,'/*'))//comment block
		{
			Game.commenting=1;
		}
		else if (beginsWith(data,'*/'))//end comment block
		{
			Game.commenting=0
		}
		else if (Game.commenting) {}
		else if (data.length<=0) {}
		else if (beginsWith(data.toLowerCase(),'$[note] '))
		{
			data=data.replace(/\$\[note\] /i,'');
			//console.log('Note : '+data);
		}
		else if (beginsWith(data.toLowerCase(),'$include '))
		{
			data=data.replace(/\$include /i,'');
		}
		else if (beginsWith(data.toLowerCase(),'$name : '))
		{
			data=data.replace(/\$name : /i,'');
			Game.name=data;
		}
		else if (beginsWith(data.toLowerCase(),'$author : '))
		{
			data=data.replace(/\$author : /i,'');
			Game.author=data;
		}
		else if (beginsWith(data.toLowerCase(),'$picture : '))
		{
			data=data.replace(/\$picture : /i,'');
			Game.picture=data;
		}
		else if (beginsWith(data.toLowerCase(),'$description : '))
		{
			data=data.replace(/\$description : /i,'');
			Game.desc=data;
		}
		else if (beginsWith(data.toLowerCase(),'$button : '))
		{
			data=data.replace(/\$button : /i,'');
			Game.again=data;
		}
		else if (beginsWith(data.toLowerCase(),'$amount : '))
		{
			data=data.replace(/\$amount : /i,'');
			if (!Game.amount) Game.amount=Math.max(1,Math.min(50,parseInt(data)))||1;
		}
		else if (data.toLowerCase()=='$force unique')
		{
			Game.allUnique=1;
		}
		else if (data.toLowerCase()=='$allow duplicates')
		{
			Game.allUnique=0;
		}
		else if (data[0]=='$')
		{
			data=data.substring(1);
			if (data[0]=='+')
			{
				data=data.substring(1);
				if (Game.ListNames.indexOf(data.toLowerCase())!=-1) Game.inList=Game.Lists[data];
				else Game.inList=new Game.List(data);
			}
			else
			{
				if (Game.ListNames.indexOf(data.toLowerCase())!=-1) {Game.Lists[data].data=[];Game.inList=Game.Lists[data];}
				else Game.inList=new Game.List(data);
			}
		}
		else
		{
			if (Game.inList)
			{
				var tags={chance:1,custom:{}};
				//modifier tags
				if (data.charAt(data.length-1)=='}' && data.indexOf(' {')!=-1)
				{
					var tagstr=data.substring(data.indexOf('{')+1,data.lastIndexOf('}'));
					tagstr=tagstr.split('}{');
					for (var i in tagstr)
					{
						if (tagstr[i].charAt(tagstr[i].length-1)=='%') tags.chance=parseFloat(tagstr[i].substring(0,tagstr[i].length-1))*0.01;
						else if (tagstr[i].indexOf(':')!=-1)
						{
							tagstr[i]=tagstr[i].split(':');
							tags.custom[tagstr[i][0].toLowerCase()]=tagstr[i][1];
						}
					}
					data=data.substring(0,data.indexOf(' {'));
				}

				Game.inList.data.push({'text':data,'tags':tags,'type':Game.inList.name});
				//console.log('Pushed '+data+' (chance : '+tags.chance+') to list '+Game.inList.name);
			}
		}
	}

	Game.ParseTag=function(tag,toObj,unique)
	{
		log('Now parsing '+tag+'.');
		Game.nesting++;
		var out='';
		var obj=0;
		var meta=[];
		var times=1;
		var identifier=0;
		var as='';
		var hidden=0;
		var unique=Game.allUnique||unique||0;
		var title=0;
		var lower=0;
		var written=0;
		var part=0;
		var compress=0;
		var casing=Game.GetCase(tag);
		var defaults='';
		if (tag.indexOf('|')!=-1)
		{
			var str=tag.split('');
			var arr=[];
			var bit='';
			var ignore=0;
			for (var i in str)
			{
				if (str[i]=='[') {bit+=str[i];ignore++;}
				else if (str[i]==']') {bit+=str[i];ignore--;}
				else if (str[i]=='|' && ignore<=0) {arr.push(bit);bit='';}
				else {bit+=str[i];}
			}
			arr.push(bit);
			if (toObj && 1==2)//don't
			{
				if (unique) {obj=Game.ParseToObj(chooseWithLimits(arr,Game.uniques));out=obj.text;}
				else {obj=Game.ParseToObj(choose(arr));out=obj.text;}
			}
			else
			{
				if (unique) {out+=Game.Parse(chooseWithLimits(arr,Game.uniques));}
				else out+=Game.Parse(choose(arr));
			}
			if (unique) {Game.uniques.push(out);}
		}
		else
		{
			if (tag.indexOf(',')!=-1)
			{
				meta=tag.split(',');
				tag=meta.shift();
				for (var i in meta)
				{
					if (meta[i].charAt(0)=='x')//several
					{
						times=meta[i].substring(1);
						times=times.split('-');times[0]=parseInt(times[0]);times[1]=parseInt(times[1]||times[0]);
						times=Math.min(Math.floor(Math.random()*((times[1]+1)-times[0])+times[0]),50);
					}
					else if (meta[i].charAt(0)=='#')//keep the same
					{
						identifier=meta[i].substring(1);//parseInt(meta[i].substring(1));
					}
					else if (beginsWith(meta[i],'as '))//use another version of the word
					{
						as=(meta[i].substring(3)).toLowerCase();
					}
					else if (beginsWith(meta[i],'or '))//default to something else if the "as" isn't available
					{
						defaults=(meta[i].substring(3));
					}
					else if (meta[i]=='hidden')//don't display it
					{
						hidden=1;
					}
					else if (meta[i]=='unique')//add it to the list of non-repeatables
					{
						unique=1;
					}
					else if (meta[i]=='title')//cap every first letter
					{
						title=1;
					}
					else if (meta[i]=='lower')//everything to lower case
					{
						lower=1;
					}
					else if (meta[i]=='compress')//remove all spaces
					{
						compress=1;
					}
					else if (meta[i]=='written')//record the same text
					{
						written=1;
					}
					else if (meta[i]=='first part') part=1;
					else if (meta[i]=='middle part') part=2;
					else if (meta[i]=='last part') part=3;
					else//set the letter case
					{
						casing=Game.GetCase(meta[i]);
						tag=Game.SetCase(tag,casing);
					}
				}
			}
			if (tag.charAt(0)=='#')
			{
				var id=tag.substring(1);//parseInt(tag.substring(1));
				if (!Game.identified[id]) {}//console.log('Can\'t find an identifier for '+id+'.');
				else
				{
					for (var i=0;i<times;i++)
					{
						obj=Game.identified[id];
						if (as!='' && typeof obj!='string')
						{
							if (as.charAt(0)=='#')
							{
								var asId=as.substring(1);
								if (!Game.identified[asId] || typeof Game.identified[asId]!='string') {}
								else {as=Game.identified[asId];}
							}
							if (obj.tags.custom[as])
							{
								obj=Game.ParseToObj(obj.tags.custom[as],0,unique);
							}
							else if (defaults!='')
							{
								if (typeof defaults=='string') obj=defaults;
								else obj=Game.ParseToObj(defaults,0,unique);
							}
						}
						out+=(typeof obj=='string'?obj:Game.ToText(obj,as));
					}
				}
			}
			else if (Game.ListNames.indexOf(tag.toLowerCase())!=-1)
			{
				for (var i=0;i<times;i++)
				{
					log('Generating "'+tag+'"...');
					if (as!='' && as.charAt(0)=='#')
					{
						var asId=as.substring(1);
						if (!Game.identified[asId] || typeof Game.identified[asId]!='string') {}
						else {as=Game.identified[asId];}
					}
					obj=Game.Lists[tag.toLowerCase()].Generate(as,1);
					log('We got "'+obj.text+'".');
					if (identifier && typeof obj!='string' && (obj.text.split('[').length-1)==1)
					{
						var oldObj=obj;
						obj=Game.ParseToObj(obj.text);
						if (typeof obj=='string') obj=oldObj;
						log('Refined into "'+obj.text+'".');
					}
					var text='';
					if (typeof obj=='string') text=obj;
					else text=Game.ToText(obj,as);
					out+=text;
					if (unique) {Game.uniques.push(obj.text);}
					log('Generated "'+obj.text+'" into "'+text+'".');
				}
			}
			else if (tag.indexOf('-')!=-1 && tag.replace('-','')==parseInt(tag.replace('-','')))
			{
				var number=tag.split('-');number[0]=parseInt(number[0]);number[1]=parseInt(number[1]);
				out+=Math.floor(Math.random()*((number[1]+1)-number[0])+number[0]);
			}
			else if (tag=='') out+='';
			else if (tag=='/') out+='<br>';
			else if (tag.toLowerCase()=='author\'s name') out+=Game.author;
			else if (tag.toLowerCase()=='game\'s name') out+=Game.name;
			else if (tag=='*CLEAR*') {out+='';Game.identified=[];}
			else if (tag=='===') {log('=========================');out+='';}
			else if (tag=='*DEBUG ON*') {Game.debugging=1;out+='';}
			else if (tag=='*DEBUG OFF*') {Game.debugging=0;out+='';}
			else out+='['+tag+']';
			if (identifier)
			{
				if (written)
				{
					var text=Game.ToText(obj,as);
					Game.identified[identifier]=Game.SetCase(out,casing);//Game.SetCase(text,Game.GetCase(tag));
					out=Game.identified[identifier];
				}
				else Game.identified[identifier]=obj;
				log('Stored "'+obj.text+'" into '+identifier+'.');
			}
			if (part==1) out=out.substring(0,Math.ceil(out.length/3));
			else if (part==2) out=out.substring(Math.floor(out.length/3),Math.ceil(out.length/3*2));
			else if (part==3) out=out.substring(Math.floor(out.length/3*2));
			if (lower) out=out.toLowerCase();
			if (title) out=Title(out);
			if (compress) out=replaceAll(' ','',out);
			if (hidden) out='';
		}
		out=Game.SetCase(out,casing);
		Game.nesting--;
		log('Done parsing '+tag+' : "'+((obj && typeof obj!='string')?(obj.text+' (object)'):(out+' (raw)'))+'".');
		return toObj?(obj||out):out;
	}
	Game.Parse=function(data)
	{
		data=data||'';
		var me=data.split('');
		var out='';
		var tag='';
		var intag=0;
		var ignore=0;
		for (var i in me)
		{
			if (me[i]=='[' && !intag) {intag=1;tag='';}
			else if (me[i]=='[' && intag) {ignore++;tag+=me[i];}
			else if (me[i]==']' && intag && ignore) {ignore--;tag+=me[i];}
			else if (me[i]==']' && intag)
			{
				var tagCase=tag.split(' ');tagCase=tagCase[tagCase.length-1];
				var text=Game.ParseTag(tag);
				out+=Game.SetCase(text,Game.GetCase(tagCase));
				log('Parsed : '+(text)+'.');
				intag=0;
				tag='';
			}
			else if (intag)
			{
				tag+=me[i];
			}
			else
			{
				out+=me[i];
			}
		}
		return out;
	}
	Game.ParseToObj=function(data,toObj,unique)
	{
		data=data||'';
		var me=data.split('');
		var out='';
		var tag='';
		var intag=0;
		var ignore=0;
		for (var i in me)
		{
			if (me[i]=='[' && !intag) {intag=1;tag='';}
			else if (me[i]=='[' && intag) {ignore++;tag+=me[i];}
			else if (me[i]==']' && intag && ignore) {ignore--;tag+=me[i];}
			else if (me[i]==']' && intag)
			{
				var tagCase=tag.split(' ');tagCase=tagCase[tagCase.length-1];
				out=Game.ParseTag(tag,1,unique);
				log('Parsed "'+tag+'" to obj : '+(typeof out=='string'?(out+' (raw)'):(out.text))+'.');
				intag=0;
				tag='';
				return out;
			}
			else if (intag)
			{
				tag+=me[i];
			}
			else
			{
				out+=me[i];
			}
		}
		log('Parsed to failed obj : '+out+'.');
		return out;
	}


	//second pass, for stuff like [an] etc
	Game.Reparse=function(data)
	{
		//data=data.replace(/\s+/g,' ');
		var me=data.split('');
		var out='';
		var tag='';
		var intag=0;
		for (var i in me)
		{
			if (me[i]=='[') {intag=1;tag='';}
			else if (me[i]==']' && intag)
			{
				if (tag.toLowerCase()=='a' || tag.toLowerCase()=='an')
				{
					var letter='';
					var ii=1;
					var inTag=false;
					while (me[parseInt(i)+ii] && letter=='')
					{
						if (me[parseInt(i)+ii]=='<') inTag=true;
						else if (me[parseInt(i)+ii]=='>') inTag=false;
						else if (me[parseInt(i)+ii]!=' ' && !inTag) letter=me[parseInt(i)+ii].toLowerCase();
						ii++;
					}
					//if (me[parseInt(i)+2]) letter=me[parseInt(i)+2].toLowerCase();
					var word='a';
					if (letter=='a' || letter=='e' || letter=='i' || letter=='o' || letter=='u' || letter=='y') word='an';
					out+=Game.SetCase(word,Game.GetCase(tag));
				}
				else if (tag.toLowerCase()=='s')
				{
					var lastWord=' '+out;
					var start=lastWord.lastIndexOf(' ')+1;
					var lastWord=lastWord.substring(start);
					out=out.substring(0,start-1)+Game.SetCase(owl.pluralize(lastWord),Game.GetCase(lastWord));
				}
				else if (tag==' ')
				{
					out+=' ';
				}
				else out+='['+tag+']';
				intag=0;
				tag='';
			}
			else if (intag)
			{
				tag+=me[i];
			}
			else
			{
				out+=me[i];
			}
		}
		return out;
	}

	Game.Generate=function()
	{
		if (!Game.amount) Game.amount=1;
		var seed=Game.seed;
		if (seed!='' && Game.ListNames.indexOf(seed.toLowerCase())!=-1) seed=Game.Lists[seed];
		else seed=Game.inList;
		var str='';
		for (var i=0;i<Game.amount;i++)
		{
			Game.Reset();
			str+='<div class="generation">'+tidy(sanitize(Game.Reparse(seed.Generate())))+'</div>';
		}
		l('amountInput').value=Game.amount||'1';
		l('text').innerHTML=str;
	}


	l('quickGameData').onkeyup=function(e)
	{
		if (this.value.length>0) document.location.hash='&data='+encodeURIComponent(this.value);
		else document.location.hash='';
		Game.FetchData();
    }

	l('amountInput').onkeyup=function(e)
	{
		Game.amount=Math.max(1,Math.min(50,parseInt(this.value)))||1;
    }

	Game.css=document.createElement('style');
	Game.type='text/css';
	document.getElementsByTagName('head')[0].appendChild(Game.css);

	l('quickCSS').onkeyup=function(e)
	{
		Game.css.innerHTML=this.value;
	}

	Game.UseUrlData=function()
	{
		Game.ParseData(decodeURIComponent(Game.urlData));
	}

	Game.FetchData=function()
	{
		Game.name='Untitled';
		Game.author='anonymous';
		Game.picture='';
		Game.desc='';
		Game.again='Generate';
		Game.allUnique=1;

		Game.urlVars=getUrlVars();
		Game.src=Game.urlVars.gen||'';
		Game.seed=replaceAll('+',' ',Game.urlVars.seed||'');
		if (Game.urlVars.amount) Game.amount=Math.max(1,Math.min(50,parseInt(Game.urlVars.amount)))||1;
		if (Game.src=='') {}
		else if (Game.src.indexOf('www.')==-1 && Game.src.indexOf('http://')==-1 && Game.src.indexOf('https://')==-1)
		{
			if (Game.src.indexOf('.txt')==-1) Game.src='http://pastebin.com/raw.php?i='+Game.src;
			else Game.src='http://orteil.dashnet.org/randomgen/gens/'+Game.src;
		}
		Game.urlData=Game.urlVars.data||'';

		if (Game.src!='')
		{
			Game.Reset();
			l('quickGameData').value=decodeURIComponent(Game.urlData);
			Game.inList=0;
			Game.ListNames=[];
			Game.Lists={};
			if (Game.urlData!='') Game.UseUrlData();
			else Game.FetchGame();
		}
		else
		{
			l('game').className='homeLoaded';
			if (Game.urlVars['do']=='create') l('game').className='createLoaded';
		}
	}

	Game.FetchData();
}


/*=====================================================================================
LAUNCH THIS THING
=======================================================================================*/

window.onload=function()
{
	if (!Game.ready) Game.Init();
};
